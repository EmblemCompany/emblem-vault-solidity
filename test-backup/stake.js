const { ethers, network } = require('hardhat');
const { expect } = require('chai')
const Util = require('./util.js')
const HDWalletProvider = require("@truffle/hdwallet-provider")
const Web3 = require('web3');
const Merklescript = require('merklescript')
const util = new Util()

const timeTravel = async (seconds) => {
  await network.provider.send("evm_increaseTime", [seconds])
  await network.provider.send("evm_mine") // this one will have 02:00 PM as its timestamp
}

beforeEach(async ()=>{
  await util.deploy();
})

describe('NFT Stake', () => {    
  it('should deploy staking contract', async ()=>{    
    let stake = await util.factory.stakeImplementation()
    // console.log(stake)
    expect(stake).to.exist
  })
  it('should not accept NFT if not initialized', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)
    let owner = await emblemContract.ownerOf(1)
    await expect(owner).to.equal(util.deployer.address)
    await emblemContract.setApprovalForAll(util.handler.address, true)
    let stakingFail = util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 0)
    expect(stakingFail).to.be.revertedWith('Not initialized')
  })
  it('should accept NFT if initialized', async ()=>{
    await util.cloneHandler(util.deployer.address)    
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)
    let owner = await emblemContract.ownerOf(1)
    await expect(owner).to.equal(util.deployer.address)
    await emblemContract.setApprovalForAll(util.handler.address, true)
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 0)
    nftOwner = await emblemContract.ownerOf(1)
    expect(nftOwner).to.equal(stakeContract.address)    
  })

  it('staking one should record one staked NFT', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)
    let owner = await emblemContract.ownerOf(1)
    await expect(owner).to.equal(util.deployer.address)
    await emblemContract.setApprovalForAll(util.handler.address, true)
    let qtyStaked = await stakeContract.qtyStaked(emblemAddress, util.deployer.address)
    expect(qtyStaked).to.equal(0)
    let nftOwner = await emblemContract.ownerOf(1)
    expect(nftOwner).to.equal(util.deployer.address)
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 0)
    qtyStaked = await stakeContract.qtyStaked(emblemAddress, util.deployer.address)
    expect(qtyStaked).to.equal(1)
    nftOwner = await emblemContract.ownerOf(1)
    expect(nftOwner).to.equal(stakeContract.address)
    let allStaked = await stakeContract.getStaked(emblemAddress, util.deployer.address)
    expect(allStaked[0]).to.equal(1)
  })
  it('staking one should record expected value', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)    
    await emblemContract.setApprovalForAll(util.handler.address, true)    
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 100)
    let nftValue = await stakeContract.getNftValue(emblemAddress, 1)
    expect(nftValue).to.equal(100)
    let totalNftValue = await stakeContract.getTotalNftValue(emblemAddress, util.deployer.address)
    expect(totalNftValue).to.equal(100)
  })
  it('staking two should record two staked NFTs', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)
    await emblemContract.mint(util.deployer.address, 2, "test", 0x0)    
    await emblemContract.setApprovalForAll(util.handler.address, true)    
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 0)
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 2, 0)
    let qtyStaked = await stakeContract.qtyStaked(emblemAddress, util.deployer.address)
    expect(qtyStaked).to.equal(2)
    let nftOwner = await emblemContract.ownerOf(1)
    expect(nftOwner).to.equal(stakeContract.address)
    nftOwner = await emblemContract.ownerOf(2)
    expect(nftOwner).to.equal(stakeContract.address)
    let allStaked = await stakeContract.getStaked(emblemAddress, util.deployer.address)
    expect(allStaked.length).to.equal(2)
    expect(allStaked[0]).to.equal(1)
    expect(allStaked[1]).to.equal(2)
  })

  it('staking two should record expected value for each', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)
    await emblemContract.mint(util.deployer.address, 2, "test", 0x0)    
    await emblemContract.setApprovalForAll(util.handler.address, true)    
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 20)
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 2, 30)
    let nftValue = await stakeContract.getNftValue(emblemAddress, 1)
    expect(nftValue).to.equal(20)
    nftValue = await stakeContract.getNftValue(emblemAddress, 2)
    expect(nftValue).to.equal(30)
    let totalNftValue = await stakeContract.getTotalNftValue(emblemAddress, util.deployer.address)
    expect(totalNftValue).to.equal(50)
  })
  
  it('un-staking one should reflect correct number of staked NFTs', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)
    await emblemContract.mint(util.deployer.address, 2, "test", 0x0)    
    await emblemContract.setApprovalForAll(util.handler.address, true)    
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 0)
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 2, 0)
    let qtyStaked = await stakeContract.qtyStaked(emblemAddress, util.deployer.address)
    expect(qtyStaked).to.equal(2)
    let allStaked = await stakeContract.getStaked(emblemAddress, util.deployer.address)
    expect(allStaked.length).to.equal(2)
    await stakeContract.unStake(emblemAddress, 1)
    let isStaked = await stakeContract.isStaked(emblemAddress, util.deployer.address, 1)
    expect(isStaked).to.equal(false)
    qtyStaked = await stakeContract.qtyStaked(emblemAddress, util.deployer.address)
    expect(qtyStaked).to.equal(1)
    allStaked = await stakeContract.getStaked(emblemAddress, util.deployer.address)
    expect(allStaked.length).to.equal(1)
  })
  it('un-staking one should reflect correct value for staked NFT', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)
    await emblemContract.mint(util.deployer.address, 2, "test", 0x0)    
    await emblemContract.setApprovalForAll(util.handler.address, true)    
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 70)
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 2, 30)
    let nftValue = await stakeContract.getNftValue(emblemAddress, 1)
    expect(nftValue).to.equal(70)
    let totalNftValue = await stakeContract.getTotalNftValue(emblemAddress, util.deployer.address)
    expect(totalNftValue).to.equal(100)
    await stakeContract.unStake(emblemAddress, 1)
    nftValue = await stakeContract.getNftValue(emblemAddress, 1)
    expect(nftValue).to.equal(0)
    totalNftValue = await stakeContract.getTotalNftValue(emblemAddress, util.deployer.address)
    expect(totalNftValue).to.equal(30)
  })
  it('un-staking one should return to owner', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)
    await emblemContract.mint(util.deployer.address, 2, "test", 0x0)    
    await emblemContract.setApprovalForAll(util.handler.address, true)    
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 0)
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 2, 0)
    await stakeContract.unStake(emblemAddress, 1)
    let nftOwner = await emblemContract.ownerOf(1)
    expect(nftOwner).to.equal(util.deployer.address)
    let allStaked = await stakeContract.getStaked(emblemAddress, util.deployer.address)
    expect(allStaked.length).to.equal(1)
  })
  it('un-staking two should reflect correct number of staked NFTs', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)
    await emblemContract.mint(util.deployer.address, 2, "test", 0x0)    
    await emblemContract.setApprovalForAll(util.handler.address, true)    
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 0)
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 2, 0)
    await stakeContract.unStake(emblemAddress, 1)    
    await stakeContract.unStake(emblemAddress, 2)
    let isStaked = await stakeContract.isStaked(emblemAddress, util.deployer.address, 2)
    expect(isStaked).to.equal(false)
    let qtyStaked = await stakeContract.qtyStaked(emblemAddress, util.deployer.address)
    expect(qtyStaked).to.equal(0)
    let allStaked = await stakeContract.getStaked(emblemAddress, util.deployer.address)
    expect(allStaked.length).to.equal(0)
  })
  it('un-staking two should reflect correct NFT values', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)
    await emblemContract.mint(util.deployer.address, 2, "test", 0x0)
    await emblemContract.setApprovalForAll(util.handler.address, true)    
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 1000)
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 2, 1000)
    await stakeContract.unStake(emblemAddress, 1)
    await stakeContract.unStake(emblemAddress, 2)
    let nftValue = await stakeContract.getNftValue(emblemAddress, 1)
    expect(nftValue).to.equal(0)
    let totalNftValue = await stakeContract.getTotalNftValue(emblemAddress, util.deployer.address)
    expect(totalNftValue).to.equal(0)
    
  })
  it('re-staking one should reflect correct number of staked NFTs', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)
    await emblemContract.mint(util.deployer.address, 2, "test", 0x0)    
    await emblemContract.setApprovalForAll(util.handler.address, true)
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 0)
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 2, 0)
    await stakeContract.unStake(emblemAddress, 1)    
    await stakeContract.unStake(emblemAddress, 2)
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 2, 0)    
    let isStaked = await stakeContract.isStaked(emblemAddress, util.deployer.address, 2)
    expect(isStaked).to.equal(true)
    let qtyStaked = await stakeContract.qtyStaked(emblemAddress, util.deployer.address)
    expect(qtyStaked).to.equal(1)
  })
  it('un-staking same nft twice should revert', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)
    await emblemContract.mint(util.deployer.address, 2, "test", 0x0)    
    await emblemContract.setApprovalForAll(util.handler.address, true)    
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 0)
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 2, 0)
    await stakeContract.unStake(emblemAddress, 1)
    let failStake = stakeContract.unStake(emblemAddress, 1)
    await expect(failStake).to.be.revertedWith('Not staked by sender')
  })

  it('staking nft should reflect correct block', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)   
    await emblemContract.setApprovalForAll(util.handler.address, true)    
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 0)
    let currentBlockNumber = await ethers.provider.getBlockNumber();
    let tokenBlockStaked = await stakeContract.getBlockNumberNftStakedAt(emblemAddress, 1)
    expect(tokenBlockStaked).to.equal(currentBlockNumber)
  })
  it('un-staking nft should reflect block 0', async ()=>{
    await util.cloneHandler(util.deployer.address)
    let emblemAddress = await util.factory.emblemImplementation()
    let stake = await util.factory.stakeImplementation()
    let stakeContract = util.getStaking(stake, util.deployer)
    await stakeContract.init()
    let emblemContract = await util.getEmblemVault(emblemAddress, util.deployer)
    await util.handler.transferNftOwnership(emblemAddress, util.deployer.address)
    await emblemContract.mint(util.deployer.address, 1, "test", 0x0)   
    await emblemContract.setApprovalForAll(util.handler.address, true)    
    await util.handler.transferToStaking(emblemAddress, stakeContract.address, 1, 0)
    await stakeContract.unStake(emblemAddress, 1)
    let tokenBlockStaked = await stakeContract.getBlockNumberNftStakedAt(emblemAddress, 1)
    expect(tokenBlockStaked).to.equal(0)
  })

})


function getRandom(myArray) {
  let selected = myArray[Math.floor(Math.random() * myArray.length)];
  return selected
}
function getWitnessSignature(web3, hash, cb) {
  web3.eth.getAccounts().then(async (accounts) => {
      var currentAccount = accounts[0].toLowerCase()
      return web3.eth.sign(hash, currentAccount, (err, res) => {
          return cb(res)
      })
  })
}
function selectProvider(network) {
  return new HDWalletProvider(process.env.ETHKEY || "a819fcd7afa2c39a7f9baf70273a128875b6c9f03001b218824559ccad6ef11c", selectProviderEndpoint(network), 0, 1)
}
function selectProviderEndpoint(network) {
  return infuraEndpoints.filter(item => { return item.network == network })[0].address
}
const MATIC_IDS = [
  "41f5f3cbf83536b2bf235d2be67a16bf6e5647dd"
]
const INFURA_IDS = [
  "6112845322b74decbf08005aea176252", // <-- free backup
  "8e5d2af8fbe244f7b7f32e2ddc152508",
  "2e2998d61b0644fe8174bca015096245"
]
const infuraEndpoints = [
  { network: "rinkeby", address: "https://rinkeby.infura.io/v3/" + getRandom(INFURA_IDS) || INFURA_ID },
  { network: "mainnet", address: "https://mainnet.infura.io/v3/" + getRandom(INFURA_IDS) || INFURA_ID },
  { network: "mumbai", address: "https://rpc-mumbai.maticvigil.com/v1/" + getRandom(MATIC_IDS) },
  { network: "matic", address: "https://rpc-mainnet.maticvigil.com/v1/" + getRandom(MATIC_IDS) },
  { network: "xdai", address: "https://rpc.xdaichain.com/" },
  { network: "bsc", address: "https://bsc-dataseed.binance.org/" },
  { network: "fantom", address: "https://rpcapi.fantom.network" }
]
