const { ethers } = require('hardhat');
const { CID } = require('multiformats/cid');
const { expect } = require('chai')
const path = require('path')
const Util = require('./util.js')
const HDWalletProvider = require("@truffle/hdwallet-provider")
const Web3 = require('web3');
const TEST_CALLBACK_FUNCTION = "0x684ee7de" //web3.eth.abi.encodeFunctionSignature('testCallback(address _from, address _to, uint256 tokenId)').substr(0, 10)
const TEST_REVERT_CALLBACK_FUNCTION = "0x5d1c03dd"
function getRandom(myArray) {
    let selected = myArray[Math.floor(Math.random() * myArray.length)];
    return selected
  }
let selectProvider = function(network) {
    return new HDWalletProvider(process.env.ETHKEY || "c1fc1fe3db1e71bb457c5f8f10de8ff349d24f30f56a1e6a92e55ef90d961328", selectProviderEndpoint(network), 0, 1)
  }
  function selectProviderEndpoint(network) {
    return infuraEndpoints.filter(item => { return item.network == network })[0].address
  }
  const MATIC_IDS = [
    "41f5f3cbf83536b2bf235d2be67a16bf6e5647dd"
  ]
  const INFURA_IDS = [  
    "6112845322b74decbf08005aea176252", // <-- free backup
    "8e5d2af8fbe244f7b7f32e2ddc152508",
    "2e2998d61b0644fe8174bca015096245"
  ]
  const infuraEndpoints = [
    { network: "rinkeby", address: "https://rinkeby.infura.io/v3/" + getRandom(INFURA_IDS) || INFURA_ID },
    { network: "mainnet", address: "https://mainnet.infura.io/v3/" + getRandom(INFURA_IDS) || INFURA_ID },
    { network: "mumbai", address: "https://rpc-mumbai.maticvigil.com/v1/" + getRandom(MATIC_IDS) },
    { network: "matic", address: "https://rpc-mainnet.maticvigil.com/v1/" + getRandom(MATIC_IDS) },
    { network: "xdai", address: "https://rpc.xdaichain.com/" },
    { network: "bsc", address: "https://bsc-dataseed.binance.org/" },
    { network: "fantom", address: "https://rpcapi.fantom.network" }
  ]
var provider = selectProvider("mainnet")
var web3 = new Web3(provider)
const util = new Util()
let ERC1155
beforeEach(async ()=>{
  await util.deploy();
  await util.cloneEmblem(util.deployer.address)
  await util.cloneHandler(util.deployer.address)  
  ERC1155 = util.getERC1155((await util.factory.erc1155Implementation()), util.deployer)
})
describe('ERC1155', () => {
    it('should deploy ERC1155 Vaults', async ()=>{
        expect(ERC1155.address).to.exist
    })
    it('should mint', async()=>{
        let balanceERC1155 = await ERC1155.balanceOf(util.bob.address, 789)
        expect(balanceERC1155).to.equal(0)
        await ERC1155.mint(util.bob.address, 789, 2)
        balanceERC1155 = await ERC1155.balanceOf(util.bob.address, 789)
        expect(balanceERC1155).to.equal(2)
    })
    it('isRegistered should return false when no handler registered', async()=>{
        let registered = await ERC1155.isRegistered(util.handler.address, 3)
        expect(registered).to.equal(false)
    })
    it('isRegistered should return true when a handler is registered', async()=>{
        await ERC1155.registerContract(util.handler.address, 3, false)
        let registered = await ERC1155.isRegistered(util.handler.address, 3)
        expect(registered).to.equal(true)
    })
    it('isRegistered should return false when a handler is unregistered', async()=>{
        await ERC1155.registerContract(util.handler.address, 3, false)
        let registered = await ERC1155.isRegistered(util.handler.address, 3)
        expect(registered).to.equal(true)
        await ERC1155.unregisterContract(util.handler.address)
        registered = await ERC1155.isRegistered(util.handler.address, 3)
        expect(registered).to.equal(false)

    })
    describe('Non-Fungibility', ()=>{
        it('should create serialnumber on each new asset minted')
        it('should add new serialnumber when minting more of a tokenid')
        it('should assign serialnumber to owner of asset')
        it('should get correct serialnumber when provided with tokenId and address')
        it('should transfer correct serialnumber from old owner to new owner on transfer')
        it('should mark correct serialnumber claimed upon claiming')
    })
    describe('Handler Callbacks', ()=>{        
        it('should not allow callback registration in handler without witness')
        it('isRegistered should return false is no handler registered', async()=>{
            let registered = await ERC1155.isRegistered(util.handler.address, 1)
            expect(registered).to.equal(false)
        })
        
        it('isRegistered should return true if handler registered', async ()=>{
            await ERC1155.registerContract(util.handler.address, 3, false)
            let registered = await ERC1155.isRegistered(util.handler.address, 3)
            expect(registered).to.equal(true)
        })
        it('should not allow adding callback if no handler registered', async ()=>{
            let isRegistered = await util.handler.isRegistered(ERC1155.address, 3)
            expect(isRegistered).to.equal(false)            
            let tx = util.handler.registerCallback(ERC1155.address, util.handler.address, 1, 0, TEST_CALLBACK_FUNCTION, false)
            await expect(tx).to.be.revertedWith("Contract is not registered")
        })
        it('should allow adding callback if handler registered', async ()=>{            
            await util.handler.registerContract(ERC1155.address, 1, false)
            let hasCallback = await util.handler.hasCallback(ERC1155.address, util.emblem.address, 1, 0)
            expect(hasCallback).to.equal(false)
            await util.handler.registerCallback(ERC1155.address, util.emblem.address, 1, 0, TEST_CALLBACK_FUNCTION, false)
            hasCallback = await util.handler.hasCallback(ERC1155.address, util.emblem.address, 1, 0)
            expect(hasCallback).to.equal(true)
        })
        it('should not have callback of different trigger', async ()=>{            
            await util.handler.registerContract(ERC1155.address, 1, false)            
            await util.handler.registerCallback(ERC1155.address, util.emblem.address, 1, 0, TEST_CALLBACK_FUNCTION, false)
            let hasCallback = await util.handler.hasCallback(ERC1155.address, util.emblem.address, 1, 1)
            expect(hasCallback).to.equal(false)
        })
        it('should allow multiple callbacks to be registered', async()=>{
            await util.handler.registerContract(ERC1155.address, 1, false)            
            await util.handler.registerCallback(ERC1155.address, util.emblem.address, 1, 0, TEST_CALLBACK_FUNCTION, false)
            await util.handler.registerCallback(ERC1155.address, util.emblem.address, 1, 1, TEST_CALLBACK_FUNCTION, false)
            let hasCallback = await util.handler.hasCallback(ERC1155.address, util.emblem.address, 1, 0)
            expect(hasCallback).to.equal(true)
            hasCallback = await util.handler.hasCallback(ERC1155.address, util.emblem.address, 1, 1)
            expect(hasCallback).to.equal(true)
        })
        
        it('can execute single mint callback', async()=>{
            let ERC721 = util.getEmblemVault(util.emblem.address, util.deployer)
            ERC721.mint(util.deployer.address, 2, "test", 0x0)
            await ERC721.setApprovalForAll(util.handler.address, true)
            await util.handler.registerContract(ERC721.address, 2, false)
            await ERC1155.registerContract(util.handler.address, 3, false)
            await util.handler.registerContract(ERC1155.address, 1, false)
            await util.handler.registerCallback(ERC1155.address, util.handler.address, 1, 0, TEST_CALLBACK_FUNCTION, false)
            await ERC1155.transferOwnership(util.handler.address)
            let ticks = await util.handler.ticks()
            expect(ticks).to.equal(0)
            await util.handler.moveVault(ERC721.address, ERC1155.address, 2, 1)
            ticks = await util.handler.ticks();
            let lastTokenId = await util.handler.lastTokenId()
            let lastTo = await util.handler.lastTo()
            expect(ticks).to.equal(1)
            expect(lastTokenId).to.equal(1)
            expect(lastTo).to.equal(util.deployer.address)
        })
        it('can handle transfer when no callbacks registered', async()=>{
            await ERC1155.mint(util.deployer.address, 789, 2)
            await ERC1155.registerContract(util.handler.address, 3, false)
            await util.handler.registerContract(ERC1155.address, 1, false)
            await ERC1155.transferOwnership(util.handler.address)
            let ticks = await util.handler.ticks()
            expect(ticks).to.equal(0)
            await ERC1155.safeTransferFrom(util.deployer.address, util.bob.address, 789, 1, 0)
            ticks = await util.handler.ticks()
            let lastTokenId = await util.handler.lastTokenId()
            let lastTo = await util.handler.lastTo()
            let lastFrom = await util.handler.lastFrom()
            expect(ticks).to.equal(0)
            expect(lastTokenId).to.equal(0)
            expect(lastTo).to.equal('0x0000000000000000000000000000000000000000')
            expect(lastFrom).to.equal('0x0000000000000000000000000000000000000000')
        })
        it('can handle transfer when no handler registered', async()=>{
            await ERC1155.mint(util.deployer.address, 789, 2)
            await ERC1155.transferOwnership(util.handler.address)
            let ticks = await util.handler.ticks()
            expect(ticks).to.equal(0)
            await ERC1155.safeTransferFrom(util.deployer.address, util.bob.address, 789, 1, 0)
            ticks = await util.handler.ticks()
            let lastTokenId = await util.handler.lastTokenId()
            let lastTo = await util.handler.lastTo()
            let lastFrom = await util.handler.lastFrom()
            expect(ticks).to.equal(0)
            expect(lastTokenId).to.equal(0)
            expect(lastTo).to.equal('0x0000000000000000000000000000000000000000')
            expect(lastFrom).to.equal('0x0000000000000000000000000000000000000000')
        })
        it('can execute single transfer callback', async()=>{
            await ERC1155.mint(util.deployer.address, 789, 2)
            let ERC721 = util.getEmblemVault(util.emblem.address, util.deployer)
            ERC721.mint(util.deployer.address, 2, "test", 0x0)
            await ERC721.setApprovalForAll(util.handler.address, true)
            await util.handler.registerContract(ERC721.address, 2, false)
            await ERC1155.registerContract(util.handler.address, 3, false)
            await util.handler.registerContract(ERC1155.address, 1, false)
            await util.handler.registerCallback(ERC1155.address, util.handler.address, 789, 1, TEST_CALLBACK_FUNCTION, true)
            await ERC1155.transferOwnership(util.handler.address)
            let ticks = await util.handler.ticks()
            expect(ticks).to.equal(0)
            await ERC1155.safeTransferFrom(util.deployer.address, util.bob.address, 789, 1, 0)
            ticks = await util.handler.ticks()
            let lastTokenId = await util.handler.lastTokenId()
            let lastTo = await util.handler.lastTo()
            let lastFrom = await util.handler.lastFrom()
            expect(ticks).to.equal(1)
            expect(lastTokenId).to.equal(789)
            expect(lastTo).to.equal(util.bob.address)
            expect(lastFrom).to.equal(util.deployer.address)
        })
        it('can execute multiple mint callbacks', async()=>{
            let ERC721 = util.getEmblemVault(util.emblem.address, util.deployer)
            ERC721.mint(util.deployer.address, 2, "test", 0x0)            
            await ERC721.setApprovalForAll(util.handler.address, true)
            await util.handler.registerContract(ERC721.address, 2, false)
            await ERC1155.registerContract(util.handler.address, 3, false)
            await util.handler.registerContract(ERC1155.address, 1, false)
            await util.handler.registerCallback(ERC1155.address, util.handler.address, 1, 0, TEST_CALLBACK_FUNCTION, false)
            await util.handler.registerCallback(ERC1155.address, util.handler.address, 1, 0, TEST_CALLBACK_FUNCTION, false)
            await ERC1155.transferOwnership(util.handler.address)
            let ticks = await util.handler.ticks()
            expect(ticks).to.equal(0)
            await util.handler.moveVault(ERC721.address, ERC1155.address, 2, 1)
            ticks = await util.handler.ticks();
            let lastTokenId = await util.handler.lastTokenId()
            let lastTo = await util.handler.lastTo()
            expect(ticks).to.equal(2)
            expect(lastTokenId).to.equal(1)
            expect(lastTo).to.equal(util.deployer.address)
        })
        it('can register wildcard callbacks', async() => {
            let ERC721 = util.getEmblemVault(util.emblem.address, util.deployer)
            ERC721.mint(util.deployer.address, 2, "test", 0x0)            
            await ERC721.setApprovalForAll(util.handler.address, true)
            await util.handler.registerContract(ERC721.address, 2, false)
            await ERC1155.registerContract(util.handler.address, 3, false)
            await util.handler.registerContract(ERC1155.address, 1, false)
            await util.handler.registerWildcardCallback(ERC1155.address, util.handler.address, 0, TEST_CALLBACK_FUNCTION, false)
            let hasCallback = await util.handler.hasCallback(ERC1155.address, util.handler.address, 0, 0)
            expect(hasCallback).to.equal(true)
        })
        it('can register wildcard callback and tokenId callback', async() => {
            let ERC721 = util.getEmblemVault(util.emblem.address, util.deployer)
            ERC721.mint(util.deployer.address, 2, "test", 0x0)            
            await ERC721.setApprovalForAll(util.handler.address, true)
            await util.handler.registerContract(ERC721.address, 2, false)
            await ERC1155.registerContract(util.handler.address, 3, false)
            await util.handler.registerContract(ERC1155.address, 1, false)
            await util.handler.registerWildcardCallback(ERC1155.address, util.handler.address, 0, TEST_CALLBACK_FUNCTION, false)
            let hasCallback = await util.handler.hasCallback(ERC1155.address, util.handler.address, 0, 0)
            expect(hasCallback).to.equal(true)
            await util.handler.registerCallback(ERC1155.address, util.handler.address, 1, 0, TEST_CALLBACK_FUNCTION, false)
            hasCallback = await util.handler.hasCallback(ERC1155.address, util.handler.address, 1, 0)
            expect(hasCallback).to.equal(true)
        })
        it('can execute single wildcard callback', async()=>{
            let ERC721 = util.getEmblemVault(util.emblem.address, util.deployer)
            ERC721.mint(util.deployer.address, 2, "test", 0x0)            
            await ERC721.setApprovalForAll(util.handler.address, true)
            await util.handler.registerContract(ERC721.address, 2, false)
            await ERC1155.registerContract(util.handler.address, 3, false)
            await util.handler.registerContract(ERC1155.address, 1, false)
            await util.handler.registerWildcardCallback(ERC1155.address, util.handler.address, 0, TEST_CALLBACK_FUNCTION, false)
            let hasCallback = await util.handler.hasCallback(ERC1155.address, util.handler.address, 0, 0)
            expect(hasCallback).to.equal(true)
            await ERC1155.transferOwnership(util.handler.address)
            let ticks = await util.handler.ticks()
            expect(ticks).to.equal(0)
            await util.handler.moveVault(ERC721.address, ERC1155.address, 2, 1)
            ticks = await util.handler.ticks();
            let lastTokenId = await util.handler.lastTokenId()
            let lastTo = await util.handler.lastTo()
            expect(ticks).to.equal(1)
            expect(lastTokenId).to.equal(1)
            expect(lastTo).to.equal(util.deployer.address)
        })
        it('can execute wildcard and tokenId callback', async()=>{
            let ERC721 = util.getEmblemVault(util.emblem.address, util.deployer)
            ERC721.mint(util.deployer.address, 2, "test", 0x0)            
            await ERC721.setApprovalForAll(util.handler.address, true)
            await util.handler.registerContract(ERC721.address, 2, false)
            await ERC1155.registerContract(util.handler.address, 3, false)
            await util.handler.registerContract(ERC1155.address, 1, false)
            await util.handler.registerCallback(ERC1155.address, util.handler.address, 1, 0, TEST_CALLBACK_FUNCTION, false)
            await util.handler.registerWildcardCallback(ERC1155.address, util.handler.address, 0, TEST_CALLBACK_FUNCTION, false)
            await ERC1155.transferOwnership(util.handler.address)
            let ticks = await util.handler.ticks()
            expect(ticks).to.equal(0)
            await util.handler.moveVault(ERC721.address, ERC1155.address, 2, 1)
            ticks = await util.handler.ticks();
            let lastTokenId = await util.handler.lastTokenId()
            let lastTo = await util.handler.lastTo()
            expect(ticks).to.equal(2)
            expect(lastTokenId).to.equal(1)
            expect(lastTo).to.equal(util.deployer.address)
        })
        it('can allow minting when no callbacks registered', async()=>{
            let ERC721 = util.getEmblemVault(util.emblem.address, util.deployer)
            ERC721.mint(util.deployer.address, 2, "test", 0x0)
            await ERC721.setApprovalForAll(util.handler.address, true)
            await util.handler.registerContract(ERC721.address, 2, false)
            await ERC1155.registerContract(util.handler.address, 3, false)
            await util.handler.registerContract(ERC1155.address, 1, false)
            await ERC1155.transferOwnership(util.handler.address)
            await util.handler.moveVault(ERC721.address, ERC1155.address, 2, 1)
            ticks = await util.handler.ticks()
            let lastTokenId = await util.handler.lastTokenId()
            let lastTo = await util.handler.lastTo()
            expect(ticks).to.equal(0)
            expect(lastTokenId).to.equal(0)
            expect(lastTo).to.equal('0x0000000000000000000000000000000000000000')
        })
        it('can revert when registered callback type allows reversion', async()=>{
            let ERC721 = util.getEmblemVault(util.emblem.address, util.deployer)
            ERC721.mint(util.deployer.address, 2, "test", 0x0)
            await ERC721.setApprovalForAll(util.handler.address, true)
            await util.handler.registerContract(ERC721.address, 2, false)
            await ERC1155.registerContract(util.handler.address, 3, false)
            await util.handler.registerContract(ERC1155.address, 1, false)
            await util.handler.registerCallback(ERC1155.address, util.handler.address, 1, 0, TEST_REVERT_CALLBACK_FUNCTION, true)
            await ERC1155.transferOwnership(util.handler.address)            
            let tx = util.handler.moveVault(ERC721.address, ERC1155.address, 2, 1)
            await expect(tx).to.be.revertedWith("Callback Reverted")
        })
        it('can catch revert when registered callback type does not allow reversion', async()=>{
            let ERC721 = util.getEmblemVault(util.emblem.address, util.deployer)
            ERC721.mint(util.deployer.address, 2, "test", 0x0)
            await ERC721.setApprovalForAll(util.handler.address, true)
            await util.handler.registerContract(ERC721.address, 2, false)
            await ERC1155.registerContract(util.handler.address, 3, false)
            await util.handler.registerContract(ERC1155.address, 1, false)
            await util.handler.registerCallback(ERC1155.address, util.handler.address, 1, 0, TEST_REVERT_CALLBACK_FUNCTION, false)
            await ERC1155.transferOwnership(util.handler.address)            
            await util.handler.moveVault(ERC721.address, ERC1155.address, 2, 1)
            let ticks = await util.handler.ticks()
            let lastTokenId = await util.handler.lastTokenId()
            let lastTo = await util.handler.lastTo()
            expect(ticks).to.equal(0)
            expect(lastTokenId).to.equal(0)
            expect(lastTo).to.equal('0x0000000000000000000000000000000000000000')
        })
        it('can continue when one failing callback type does not allow reversion', async()=>{
            let ERC721 = util.getEmblemVault(util.emblem.address, util.deployer)
            ERC721.mint(util.deployer.address, 2, "test", 0x0)
            await ERC721.setApprovalForAll(util.handler.address, true)
            await util.handler.registerContract(ERC721.address, 2, false)
            await ERC1155.registerContract(util.handler.address, 3, false)
            await util.handler.registerContract(ERC1155.address, 1, false)
            await util.handler.registerCallback(ERC1155.address, util.handler.address, 1, 0, TEST_REVERT_CALLBACK_FUNCTION, false)
            await util.handler.registerCallback(ERC1155.address, util.handler.address, 1, 0, TEST_CALLBACK_FUNCTION, false)
            await ERC1155.transferOwnership(util.handler.address)            
            await util.handler.moveVault(ERC721.address, ERC1155.address, 2, 1)
            let ticks = await util.handler.ticks()
            let lastTokenId = await util.handler.lastTokenId()
            let lastTo = await util.handler.lastTo()
            expect(ticks).to.equal(1)
            expect(lastTokenId).to.equal(1)
            expect(lastTo).to.equal(util.deployer.address)
        })
        it('can revert when one failing callback type does allow reversion', async()=>{
            let ERC721 = util.getEmblemVault(util.emblem.address, util.deployer)
            ERC721.mint(util.deployer.address, 2, "test", 0x0)
            await ERC721.setApprovalForAll(util.handler.address, true)
            await util.handler.registerContract(ERC721.address, 2, false)
            await ERC1155.registerContract(util.handler.address, 3, false)
            await util.handler.registerContract(ERC1155.address, 1, false)
            await util.handler.registerCallback(ERC1155.address, util.handler.address, 1, 0, TEST_CALLBACK_FUNCTION, false)
            await util.handler.registerCallback(ERC1155.address, util.handler.address, 1, 0, TEST_REVERT_CALLBACK_FUNCTION, true)
            await ERC1155.transferOwnership(util.handler.address)
            let tx = util.handler.moveVault(ERC721.address, ERC1155.address, 2, 1)
            await expect(tx).to.be.revertedWith("Callback Reverted")
            let ticks = await util.handler.ticks()
            let lastTokenId = await util.handler.lastTokenId()
            let lastTo = await util.handler.lastTo()
            expect(ticks).to.equal(0)
            expect(lastTokenId).to.equal(0)
            expect(lastTo).to.equal('0x0000000000000000000000000000000000000000')
        })
        
        it('should now allow callback non registrant to remove callback', async()=>{
            await util.handler.registerContract(ERC1155.address, 1, false)
            await util.handler.registerCallback(ERC1155.address, util.handler.address, 789, 1, TEST_CALLBACK_FUNCTION, true)
            let handler = util.getHandler(util.handler.address, util.bob)
            let tx = handler.unregisterCallback(ERC1155.address, util.handler.address, 789, 1, 0)
            await expect(tx).to.be.revertedWith("Not owner or Callback registrant")
        })

        it('should allow callback owner to remove tokenId callback', async()=>{
            await util.handler.registerContract(ERC1155.address, 1, false)
            let handler = util.getHandler(util.handler.address, util.bob)
            await handler.registerCallback(ERC1155.address, util.handler.address, 789, 1, TEST_CALLBACK_FUNCTION, true)
            let hasCallback = await util.handler.hasCallback(ERC1155.address, util.handler.address, 789, 1)
            expect(hasCallback).to.equal(true)
            await handler.unregisterCallback(ERC1155.address, util.handler.address, 789, 1, 0)
            hasCallback = await util.handler.hasCallback(ERC1155.address, util.handler.address, 789, 1)
            expect(hasCallback).to.equal(false)        
        })
        it('should allow callback owner to remove wildcard callback', async()=>{
            await util.handler.registerContract(ERC1155.address, 1, false)
            let handler = util.getHandler(util.handler.address, util.bob)
            await handler.registerWildcardCallback(ERC1155.address, util.handler.address, 1, TEST_CALLBACK_FUNCTION, true)
            let hasCallback = await util.handler.hasCallback(ERC1155.address, util.handler.address, 0, 1)
            expect(hasCallback).to.equal(true)
            await handler.unregisterCallback(ERC1155.address, util.handler.address, 0, 1, 0)
            hasCallback = await util.handler.hasCallback(ERC1155.address, util.handler.address, 0, 1)
            expect(hasCallback).to.equal(false)        
        })
        it('should allow contract owner to remove tokenId callback', async()=>{
            await util.handler.registerContract(ERC1155.address, 1, false)
            let handler = util.getHandler(util.handler.address, util.bob)
            await handler.registerCallback(ERC1155.address, util.handler.address, 789, 1, TEST_CALLBACK_FUNCTION, true)
            let hasCallback = await util.handler.hasCallback(ERC1155.address, util.handler.address, 789, 1)
            expect(hasCallback).to.equal(true)
            await util.handler.unregisterCallback(ERC1155.address, util.handler.address, 789, 1, 0)
            hasCallback = await util.handler.hasCallback(ERC1155.address, util.handler.address, 789, 1)
            expect(hasCallback).to.equal(false)
        })

        it('should allow contract owner to remove wildcard callback', async()=>{
            await util.handler.registerContract(ERC1155.address, 1, false)
            let handler = util.getHandler(util.handler.address, util.bob)
            await handler.registerWildcardCallback(ERC1155.address, util.handler.address, 1, TEST_CALLBACK_FUNCTION, true)
            let hasCallback = await util.handler.hasCallback(ERC1155.address, util.handler.address, 0, 1)
            expect(hasCallback).to.equal(true)
            await util.handler.unregisterCallback(ERC1155.address, util.handler.address, 0, 1, 0)
            hasCallback = await util.handler.hasCallback(ERC1155.address, util.handler.address, 0, 1)
            expect(hasCallback).to.equal(false)
        })
    })
})